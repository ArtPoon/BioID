
<style>
  div.wrapper {
    text-align: center;
  }
  div.njtree {
    text-align: center;
  }
  .link {
    stroke: #aaa;
    stroke-width: 2px;
  }

  .textClass {
    stroke: #323232;
    font-family: "Cabin", "Droid Sans", Arial, Helvetica, sans-serif;
    font-weight: normal;
    stroke-width: .5;
    font-size: 14px;
  }
</style>


<div id="wrapper">
  <input type="button" value="Down" onclick="prevStage()"/>
  <input type="button" value="Up" onclick="nextStage()"/>
  <output id="stage_display">0</output>
  <div id="njtree"></div>
</div>


<script src="/public/js/d3.v3.min.js"></script>
<script src="/public/js/jquery.min.js"></script>

<script>

// adapted by @ArtPoon from http://bl.ocks.org/hugolpz/cd89b50d834828261b45af9e7a5ce926


var w = 600,  // width
    h = 300;  // height


var vis = d3.select("div#njtree")
            .append("svg:svg")
            .attr("width", w)
            .attr("height", h)
            .attr("id", "mySvg")
            .attr("pointer-events", "all")
            .attr("viewBox", "0 0 " + w + " " + h)
            .attr("perserveAspectRatio", "xMinYMid meet")
            .append('svg:g');

// position linked nodes using physical simulation
var force = d3.layout.force();

var nodes = force.nodes(),
    links = force.links();
        
var graph;
//var vis;
var data = {
  "links": [
    {'dist': 0.5, 'source': "root", 'target': "A"},
    {'dist': 0.5, 'source': "root", 'target': "B"},
    {'dist': 0.5, 'source': "root", 'target': "C"},
    {'dist': 0.5, 'source': "root", 'target': "D"},
    {'dist': 0.5, 'source': "root", 'target': "E"},
    {'dist': 0.5, 'source': "root", 'target': "F"},
    {'dist': 0.5, 'source': "root", 'target': "G"},
    {'dist': 0.5, 'source': "root", 'target': "H"},
  ], 
  "nodes": [
    {'id': "root", "group": "0", "r": 0.1}, 
    {'id': "A", "group": "0", "r": 0.1},
    {'id': "B", "group": "0", "r": 0.1},
    {'id': "C", "group": "0", "r": 0.1},
    {'id': "D", "group": "0", "r": 0.1}, 
    {'id': "E", "group": "0", "r": 0.1}, 
    {'id': "F", "group": "0", "r": 0.1}, 
    {'id': "G", "group": "0", "r": 0.1}, 
    {'id': "H", "group": "0", "r": 0.1}, 
  ]
};



function myGraph() {
    this.addNode = function(id, r) {
        nodes.push({"id": id, "r": r})
        update();
    };

    this.removeNode = function(id) {
        var i = 0;
        var n = this.findNode(id);
        if (n == null) {
            // no node with this 'id'
            return;  // returns undefined
        }

        while (i < links.length) {
            if ((links[i]['source'] == n) || (links[i]['target'] == n)) {
                // remove links that connect to this node
                links.splice(i, 1);
            }
            else i++;
        }
        nodes.splice(this.findNodeIndex(id), 1);
        update();
    };

    this.removeLink = function (source, target) {
        // remove directed edge between nodes with given IDs, if it exists
        var link;
        for (var i = 0; i < links.length; i++) {
            link = links[i];
            if ((link.source.id == source && link.target.id == target) || 
                (link.source.id == target && link.target.id == source)) {
                links.splice(i, 1);
                break;
            }
        }
        // if no matching edge, no big deal
        update();
    };

    this.removeAllLinks = function () {
        links.splice(0, links.length);
        update();
    };

    this.removeAllNodes = function () {
        nodes.splice(0, nodes.length);
        update();
    };

    this.addLink = function(source, target, dist) {
        /*
            Add link object to [links] Array between nodes specified
            by IDs.
            @param source: ID of parent node
            @param target: ID of child node
            @param dist: distance attribute (float)
         */
        var node1 = this.findNode(source),
            node2 = this.findNode(target);

        if (node1 == null || node2 == null) {
            return;  // do nothing
        }
        links.push({"source": node1, "target": node2, "dist": dist});
        update();
    };


    /* accessor functions */
    this.findNode = function(id) {
        // search through Array of node objects and return the object
        // with the requested (id)
        for (var i in nodes) {  // for..in iterates over indices
            if (nodes[i]["id"] === id) return nodes[i];
        }
        console.log("Warning: failed to retrieve node with id: "+id);
        return null;
    };

    this.findNodeIndex = function(id) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].id == id) {
                return i;
            }
        }
        console.log("Warning: failed to index node witih id: " + id);
        return null;
    };

    update();  // go!
}



var update = function() {
    var link = vis.selectAll("line")
            .data(links, function (d) {
                return d.source.id + "-" + d.target.id;
            });

    link.enter().append("line")
        .attr("id", function (d) {
            return d.source.id + '-' + d.target.id;
        })
        .attr("class", "link");
    link.exit().remove();

    var node = vis.selectAll("g.node")
        .data(nodes, function(d) {
            return d.id;
        });

    var nodeEnter = node.enter().append("g")
        .attr("class", "node")
        .call(force.drag);

    nodeEnter.append("svg:circle")
        .attr("r", function (d) { return 50*d.r; })
        .attr("id", function (d) { return d.id; })
        .attr("class", "nodeStrokeClass");

    node.exit().remove();
    
    node.select("circle")
        .style("fill", "#fff")
        .style("stroke", "#aaa")
        .style("stroke-width", "3");

    force.on("tick", function() {
        node.attr("transform", function (d) {
            return "translate(" + d.x + "," + d.y + ")";
        });

        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
    });

    // restart the force layout
    force.charge(-500)
         .linkDistance(function(d) {
            return 200*d.dist;
         })
         .size([w, h])
         .start();
};



// initialize graph
/*
graph = new myGraph();
for (var i = 0; i < data.nodes.length; i++) {
    node = data.nodes[i];
    if (node.group=="0") {
        graph.addNode(node.id, node.r);
    }
}
for (var i = 0; i < data.links.length; i++) {
    link = data.links[i];
    graph.addLink(link.source, link.target, link.dist);    
}
keepNodesOnTop();
*/

var csvdata,
    headers,
    dists,
    u;
    
d3.text("/data/nj-example.csv").get(function(error, rows) {
  csvdata = d3.csv.parseRows(rows);
  headers = csvdata[0];
  var n=headers.length;
  
  if (csvdata.length != n) {
    console.warn("Not a square matrix!");
  }
  
  // convert array into Object
  dists = {};
  for (var i=1; i < n; i++) {
    k1 = headers[i];
    dists[k1] = {};
    for (var j=1; j < n; j++) {
      k2 = headers[j];
      dists[k1][k2] = +csvdata[i][j];
    }
  }
  
  // initialize graph
  graph = new myGraph();
  graph.addNode("root", 0.1);
  for (var i=1; i<n; i++) {
    graph.addNode(headers[i], 0.1);
    graph.addLink(headers[i], "root", 0.5);
    // TODO: make these edges a fainter color
  }
  keepNodesOnTop();
  
  // initialize matrix
  u = Array(n);
  for (var i=1; i<n; i++) {
    var sum=0;
    for (var j=1; j<n; j++) {
      if (j==i) { continue; }
      sum += +csvdata[i][j];
    }
    u[i] = sum/(n-2);
    //mx[i] /= (n-2);
  }
});



var ancestors = ["A-B", "E-F", "AB-C", "ABC-D", "ABCD-EF"];

var transitions = {
  1: {"remove": [{"source": "A", "target": "root", "dist": 0.5},
              {"source": "B", "target": "root", "dist": 0.5}],
      "add": [{"source": "A", "target": "A-B", "dist": 0.1},
              {"source": "B", "target": "A-B", "dist": 0.1},
              {"source": "A-B", "target": "root", "dist": 0.1}]},
              
  2:  {"remove": [{"source": "E", "target": "root", "dist": 0.5},
              {"source": "F", "target": "root", "dist": 0.5}],
      "add": [{"source": "E", "target": "E-F", "dist": 0.1},
              {"source": "F", "target": "E-F", "dist": 0.1},
              {"source": "E-F", "target": "root", "dist": 0.1}]},
              
  3: {"remove": [{"source": "A-B", "target": "root", "dist": 0.5},
              {"source": "C", "target": "root", "dist": 0.5}],
      "add": [{"source": "A-B", "target": "AB-C", "dist": 0.1},
              {"source": "C", "target": "AB-C", "dist": 0.1},
              {"source": "AB-C", "target": "root", "dist": 0.1}]},
              
  4: {"remove": [{"source": "AB-C", "target": "root", "dist": 0.5},
              {"source": "D", "target": "root", "dist": 0.5}],
      "add": [{"source": "AB-C", "target": "ABC-D", "dist": 0.1},
              {"source": "D", "target": "ABC-D", "dist": 0.1},
              {"source": "ABC-D", "target": "root", "dist": 0.1}]},
              
  5: {"remove": [{"source": "ABC-D", "target": "root", "dist": 0.5},
              {"source": "E-F", "target": "root", "dist": 0.5}],
      "add": [{"source": "ABC-D", "target": "ABCD-EF", "dist": 0.1},
              {"source": "E-F", "target": "ABCD-EF", "dist": 0.1},
              {"source": "ABCD-EF", "target": "root", "dist": 0.1}]}
};

var stage = 0,
    removes,
    adds,
    t;


function keepNodesOnTop() {
    $(".nodeStrokeClass").each(function( index ) {
        var gnode = this.parentNode;
        gnode.parentNode.appendChild(gnode);
    });
}


function prevStage() {
  //console.log('prevStage');
  if (stage > 0) {
    stage = stage-1;
    graph.removeNode(ancestors[stage]);
    
    // reverse order of operations
    adds = transitions[stage+1]["remove"];
    for (var i=0; i<adds.length; i++) {
      t = adds[i];
      graph.addLink(t.source, t.target, t.dist);
    }
    // no need to remove links, since we killed the node
    
  }
  $("#stage_display").val(stage);
  keepNodesOnTop();
}

function nextStage() {
  //console.log('nextStage');
  if (stage < 5) {
    graph.addNode(ancestors[stage], 0.1); // ancestors is 0-indexed
    stage = stage + 1;
    
    adds = transitions[stage]["add"];
    for (var i = 0; i<adds.length; i++) {
      t = adds[i];
      graph.addLink(t.source, t.target, t.dist);
    }
    removes = transitions[stage]["remove"];
    for (var i = 0; i<removes.length; i++) {
      t = removes[i];
      graph.removeLink(t.source, t.target);
    }
  }
  $("#stage_display").val(stage);
  keepNodesOnTop();
}

</script>





