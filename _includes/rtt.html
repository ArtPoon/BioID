<style>
    table {
        width: 100%;
    }
    rect {
        fill: none;
        cursor: grab;
        pointer-events: all;
    }
</style>


<script src="{{ site.baseurl }}/public/js/jquery.min.js"></script>
<script src="{{ site.baseurl }}/public/js/d3.v3.min.js"></script>
<script src="{{ site.baseurl }}/public/js/phylo.js"></script>


<table>
    <tr>
        <td>
            <div id="unrooted"></div>
        </td>
        <td>
            <div id="rooted"></div>
        </td>
        <td>
            <div id="regression"></div>
        </td>
    </tr>
</table>

    
<script>   
    var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = 300, 
        height = 300,
        svg = d3.select("div#unrooted")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g");
    
    // set up plotting scales
    var xValue = function(d) { return d.x; },
        xScale = d3.scale.linear().range([0, width]),
        xMap = function(d) { return xScale(xValue(d)); },
        xMap1 = function(d) { return xScale(d.x1); },
        xMap2 = function(d) { return xScale(d.x2); },
        xAxis = d3.svg.axis().scale(xScale).orient("bottom");
    
    var yValue = function(d) { return d.y; },
        yScale = d3.scale.linear().range([height, 0]),
        yMap = function(d) { return yScale(yValue(d)); },
        yMap1 = function(d) { return yScale(d.y1); },
        yMap2 = function(d) { return yScale(d.y2); },
        yAxis = d3.svg.axis().scale(yScale).orient("left");
    
    var tree = readTree(example);
    equalAngleLayout(tree);

    var data = fortify(tree, sort=true),
        edgeset = edges(data);

    // add buffer to data domain
    xScale.domain([
        d3.min(data, xValue)-1, d3.max(data, xValue)+1
    ])
    yScale.domain([
        d3.min(data, yValue)-1, d3.max(data, yValue)+1
    ])

    // draw x-axis
    svg.append("g")
       .attr("class", "x axis")
       .attr("transform", "translate(0," + height + ")")
       .call(xAxis);
    
    // draw y-axis
    svg.append("g")
       .attr("class", "y axis")
       .call(yAxis);
    
    // draw points
    svg.selectAll(".dot")
       .data(data)
       .enter().append("circle")
       .attr("class", "dot")
       .attr("r", 2)
       .attr("cx", xMap)
       .attr("cy", yMap);
    
    // draw lines
    svg.selectAll("lines")
       .data(edgeset)
       .enter().append("line")
       .attr("class", "lines")
       .attr("x1", xMap1)
       .attr("y1", yMap1)
       .attr("x2", xMap2)
       .attr("y2", yMap2)
       .attr("stroke-width", 2)
       .attr("stroke", "#00000040");

    // add circle
    var circle1 = svg.append("circle")
                    .attr("cx", xScale(0))
                    .attr("cy", yScale(0))
                    .attr("r", 5)
                    .attr("fill", "red");
    
    var circle2 = svg.append("circle")
                    .attr("cx", xScale(0))
                    .attr("cy", yScale(0))
                    .attr("r", 3)
                    .attr("fill", "blue");                    

    svg.append("rect")
       .attr("width", width)
       .attr("height", height)
       .on("mousemove", function() {
           var m = d3.mouse(this),
               p = closestEdge(m);
               circle1.attr("cx", xScale(p.x))
                      .attr("cy", yScale(p.y));
       });


    // find closest edge to mouse
    function closestEdge(ptr) {
        // unpack mouse coordinates
        var px = ptr[0],
            py = ptr[1],
            dx, dy,
            adj1, adj2,  // adjacent
            hyp1, hyp2,  // hypoteneuse
            part, blen,  // partition of branch length
            dist, mindist = Infinity, 
            minpart, minblen, closest;
        
        for (const e of edgeset) {
            // first, calculate the hypoteneuse (distance
            // from ptr to each node)
            dx = px - xScale(e.x1);
            dy = py - yScale(e.y1);
            hyp1 = dx*dx + dy*dy;  // no sqrt

            dx = px - xScale(e.x2);
            dy = py - yScale(e.y2);
            hyp2 = dx*dx + dy*dy;  // no sqrt

            // branch length at user scale
            dx = xScale(e.x1) - xScale(e.x2);
            dy = yScale(e.y1) - yScale(e.y2);
            blen = Math.sqrt(dx*dx + dy*dy); 

            // next, calculate branch length part
            // note we left hyp1 and hyp2 squared
            part = (hyp1 - hyp2 + blen*blen) / 
                    (2*blen);
            if (part < 0 || part > blen) {
                continue;
            }

            // finally calculate distance to branch
            dist = Math.sqrt(hyp1 - part*part);
            //console.log(part, blen, dist);

            if (dist < mindist) {
                mindist = dist;
                minpart = part;  // this is useful
                minblen = blen;
                closest = e;
            }
        }

        //console.log(mindist, minpart, minblen);

        // solve for coordinates of point on closest edge
        var p = minpart/minblen;
        return ({
            x: (1-p)*closest.x1 + p*closest.x2,
            y: (1-p)*closest.y1 + p*closest.y2
        });
    }

    // locate the closest point on tree
    function closestPoint(point) {
        var px = point[0],
            py = point[1],
            dx, dy, angle, dist, mindist = Infinity,
            closest, closest2;

        // locate the closest point
        for (const dt of data) {
            // not necessary to square root
            dx = px - xScale(dt.x);
            dy = py - yScale(dt.y);
            dist = dx*dx + dy*dy;
            if (dist < mindist) {
                mindist = dist;
                closest = dt;  // row from data
                angle = Math.atan(dy/dx) / Math.PI;
            }
        }

        // adjust angle for quadrant
        dx = px - xScale(closest.x);
        dy = py - yScale(closest.y);
        //console.log(dx, dy);
        if (dx >= 0) {
            if (dy >= 0) {
                // do nothing
            } else {
                // lower-right, angle between -1/2 and 0
                angle += 2.
            }
        } else {
            angle += 1.
        }
        // the angle system is all screwy, need to add .5
        angle += .5
        if (angle > 2) {
            angle -= 2.
        }
        //console.log(angle);
        
        // select second point based on adjacent nodes
        var row, rays = [];
        for (const childId of closest.children) {
            row = data[childId];
            rays.push([row.angle, row]);
        }
        row = data[closest.parentId];
        if (row !== undefined) {
            // reverse direction of parental edge
            if (row.angle < 1) {
                rays.push([row.angle+1., row]);
            } else {
                rays.push([row.angle-1., row]);
            }
        }
        
        if (rays.length == 1) {
            // terminal branch
            return ({
                closest: closest,
                closest2: rays[0][1]
            });
        }
        
        // bisect rows
        rays.sort()  // sort on first element per Array
        //console.log(rays.map(x=>x[0]));

        var bisects = [];
        for (var i=0; i<rays.length; i++) {
            var ray1 = rays[i][0],  // angle
                ray2 = rays[(i+1)%rays.length][0],
                delta = Math.abs(ray2 - ray1),
                bisect = Math.min(ray1, ray2) + delta/2.;

            if (delta > 1.) {
                bisects.push(bisect-1.)
            } else {
                bisects.push(bisect);
            }   
        }

        // locate angle of pointer in sectors
        for (var i=0; i<bisects.length; i++) {
            var j = (i+1)%bisects.length,
                b1 = bisects[i],
                b2 = bisects[j];
            
            if (b2 < b1) {
                if (angle < b2 || angle > b1)
                    closest2 = rays[j][1];
            } else {
                if (angle >= b1 && angle < b2) 
                  closest2 = rays[j][1];
            }
        }
        if (closest2 === undefined) {
            console.log(angle, b1, b2);
        }

        return({
            closest: closest,
            closest2: closest2
        });
    }
</script>
