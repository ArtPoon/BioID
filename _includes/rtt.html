<style>
    table {
        width: 100%;
    }
    rect {
        fill: none;
        cursor: crosshair;
        pointer-events: all;
    }
</style>


<script src="{{ site.baseurl }}/public/js/jquery.min.js"></script>
<script src="{{ site.baseurl }}/public/js/d3.v3.min.js"></script>
<script src="{{ site.baseurl }}/public/js/phylo.js"></script>


<table>
    <tr>
        <td>
            <div id="unrooted"></div>
        </td>
        <td>
            <div id="rooted"></div>
        </td>
        <td>
            <div id="regression"></div>
        </td>
    </tr>
</table>

    
<script>   
    var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = 300, 
        height = 300,
        svg = d3.select("div#unrooted")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g");
    
    // set up plotting scales
    var xValue = function(d) { return d.x; },
        xScale = d3.scale.linear().range([0, width]),
        xMap = function(d) { return xScale(xValue(d)); },
        xMap1 = function(d) { return xScale(d.x1); },
        xMap2 = function(d) { return xScale(d.x2); },
        xAxis = d3.svg.axis().scale(xScale).orient("bottom");
    
    var yValue = function(d) { return d.y; },
        yScale = d3.scale.linear().range([height, 0]),
        yMap = function(d) { return yScale(yValue(d)); },
        yMap1 = function(d) { return yScale(d.y1); },
        yMap2 = function(d) { return yScale(d.y2); },
        yAxis = d3.svg.axis().scale(yScale).orient("left");
    
    var tree = readTree(example);
    equalAngleLayout(tree);

    var data = fortify(tree, sort=true),
        edgeset = edges(data);

    // add buffer to data domain
    xScale.domain([
        d3.min(data, xValue)-1, d3.max(data, xValue)+1
    ])
    yScale.domain([
        d3.min(data, yValue)-1, d3.max(data, yValue)+1
    ])

    // draw x-axis
    svg.append("g")
       .attr("class", "x axis")
       .attr("transform", "translate(0," + height + ")")
       .call(xAxis);
    
    // draw y-axis
    svg.append("g")
       .attr("class", "y axis")
       .call(yAxis);
    
    // draw points
    svg.selectAll(".dot")
       .data(data)
       .enter().append("circle")
       .attr("class", "dot")
       .attr("r", 2)
       .attr("cx", xMap)
       .attr("cy", yMap);
    
    // draw lines
    svg.selectAll("lines")
       .data(edgeset)
       .enter().append("line")
       .attr("class", "lines")
       .attr("x1", xMap1)
       .attr("y1", yMap1)
       .attr("x2", xMap2)
       .attr("y2", yMap2)
       .attr("stroke-width", 2)
       .attr("stroke", "#00000040");

    // add circle
    var circle1 = svg.append("circle")
                    .attr("cx", xScale(0))
                    .attr("cy", yScale(0))
                    .attr("r", 3)
                    .attr("fill", "red");
    
    var circle2 = svg.append("circle")
                    .attr("cx", xScale(0))
                    .attr("cy", yScale(0))
                    .attr("r", 3)
                    .attr("fill", "blue");                    

    svg.append("rect")
       .attr("width", width)
       .attr("height", height)
       .on("mousemove", function() {
           var m = d3.mouse(this),
               p = closestPoint(m);
               circle1.attr("cx", xScale(p.closest.x))
                      .attr("cy", yScale(p.closest.y));
               circle2.attr("cx", xScale(p.closest2.x))
                      .attr("cy", yScale(p.closest2.y));
       });

    // locate the closest point on tree
    function closestPoint(point) {
        var px = point[0],
            py = point[1],
            dx, dy, angle, dist, mindist = Infinity,
            closest, closest2;

        // locate the closest point
        for (const dt of data) {
            // not necessary to square root
            dx = px - xScale(dt.x);
            dy = py - yScale(dt.y);
            dist = dx*dx + dy*dy;
            if (dist < mindist) {
                mindist = dist;
                closest = dt;  // row from data
                angle = Math.atan(dy/dx) / Math.PI;
            }
        }

        // adjust angle for quadrant
        dx = px - xScale(closest.x);
        dy = py - yScale(closest.y);
        //console.log(dx, dy);
        if (dx >= 0) {
            if (dy >= 0) {
                // do nothing
            } else {
                // lower-right, angle between -1/2 and 0
                angle += 2.
            }
        } else {
            angle += 1.
        }
        // the angle system is all screwy, need to add .5
        angle += .5
        if (angle > 2) {
            angle -= 2.
        }
        //console.log(angle);
        
        // select second point based on adjacent nodes
        var row, rays = [];
        for (const childId of closest.children) {
            row = data[childId];
            rays.push([row.angle, row]);
        }
        row = data[closest.parentId];
        if (row !== undefined) {
            // reverse direction of parental edge
            if (row.angle < 1) {
                rays.push([row.angle+1., row]);
            } else {
                rays.push([row.angle-1., row]);
            }
        }
        
        if (rays.length == 1) {
            // terminal branch
            return ({
                closest: closest,
                closest2: rays[0][1]
            });
        }
        
        // bisect rows
        rays.sort()  // sort on first element per Array
        //console.log(rays.map(x=>x[0]));

        var bisects = [];
        for (var i=0; i<rays.length; i++) {
            var ray1 = rays[i][0],  // angle
                ray2 = rays[(i+1)%rays.length][0],
                delta = Math.abs(ray2 - ray1),
                bisect = Math.min(ray1, ray2) + delta/2.;

            if (delta > 1.) {
                bisects.push(bisect-1.)
            } else {
                bisects.push(bisect);
            }   
        }

        // locate angle of pointer in sectors
        for (var i=0; i<bisects.length; i++) {
            var j = (i+1)%bisects.length,
                b1 = bisects[i],
                b2 = bisects[j];
            
            if (b2 < b1) {
                if (angle < b2 || angle > b1)
                    closest2 = rays[j][1];
            } else {
                if (angle >= b1 && angle < b2) 
                  closest2 = rays[j][1];
            }
        }
        if (closest2 === undefined) {
            console.log(angle, b1, b2);
        }

        return({
            closest: closest,
            closest2: closest2
        });
    }
</script>
